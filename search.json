[{"categories":["网络安全"],"content":"Wireshark使用 ip.addr == 180.101.49.11 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为180.101.49.11的数据包。 三次握手原理 先来看一下基本的原理。 第一次握手：建立连接时，客户端发送SYN到服务器，并进入SYN_SENT状态。 第二次握手：服务器收到请求后，回送SYN+ACK信令到客户端，此时服务器进入SYN_RECV状态。 第三次握手：客户端收到SYN+ACK包，向服务器发送确认ACK包，客户端进入ESTABLISHED状态，服务器收到请求后也进入ESTABLISHED状态，完成三次握手，此时TCP连接成功，客户端与服务器开始传送数据。 第一次握手 第一次握手：建立连接时，客户端发送SYN到服务器，并进入SYN_SENT状态。 SYN ：标志位，表示请求建立连接。 Seq = 0 ：初始建立连接值为0，数据包的相对序列号从0开始，表示当前还没有发送数据。 Ack =0：初始建立连接值为0，已经收到包的数量，表示当前没有接收到数据。 WIN = 8192 来自Window size: 8192。 MSS = 1460 来自 Maximum segment size: 1460 byte ，最长报文段，TCP包所能携带的最大数据量，不包含TCP头和Option。一般为MTU值减去IPv4头部(至少20字节)和TCP头部(至少20字节)得到。 WS = 4 来自windows scale : 2 (multiply by 4)： 窗口扩张，放在TCP头之外的Option，向对方声明一个shift count，作为2的指数，再乘以TCP定义的接收窗口，得到真正的TCP窗口。 第二次握手 第二次握手：服务器收到请求后，回送SYN+ACK信令到客户端，此时服务器进入SYN_RECV状态。 Seq = 0 ：初始建立值为0，表示当前还没有发送数据 Ack = 1 : 表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位。尽管客户端没有发送任何有效数据，确认号还是被加1，这是因为接收的包中包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据。 第三次握手 第三次握手：客户端收到SYN+ACK包，向服务器发送确认ACK包，客户端进入ESTABLISHED状态，服务器收到请求后也进入ESTABLISHED状态，完成三次握手，此时TCP连接成功，客户端与服务器开始传送数据。 ACK ：标志位，表示已经收到记录 Seq = 1 ：表示当前已经发送1个数据 Ack = 1 : 表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位。尽管客户端没有发送任何有效数据，确认号还是被加1，这是因为接收的包中包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据) 为什么是三次握手 这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 也是为了最小的代价验证会话双方的收发功能正常: 第一次握手成功：说明客户端的数据可以被服务端收到，说明客户端的发功能可用，说明服务端的收功能可用。但客户端自己不知道数据是否被接收。 第二次握手成功：说明服务端的数据可以被客户端收到，说明服务端的发功能可用，说明客户端的收功能可用。同时客户端知道自己的数据已经正确到达服务端，自己的发功能正常。但是服务端自己不知道数据是否被接收。 第三次握手成功：说明服务端知道自己的数据已经正确到达客户端端，自己的发功能正常。至此服务成功建立。 请求数据的过程 客户端和服务端建立连接后，开始传输数据。下图中首先是客户端发起一个GET请求，服务端收到请求后首先返回确认信息。待服务端处理完成后，将数据返回给客户端，客户端对收到的数据进行确认，完成一次数据交互的过程。 交互过程中，SEQ表示发送的数据，LEN表示发送的数据长度，下一次的SEQ就等于当前SEQ加上LEN。ACK表示接收的数据位。客户端和服务端分别计算自己的增长值。对应上图最后一次服务端返回数据时SEQ是2737，LEN是450。客户端对接收数据做了两次返回确认，第一次ACK是2737，表示还没有完成数据接收。第二次ACK是3187，等于服务端SEQ＋LEN（2737+450）表示已经完成了全部数据的接收。 第一次挥手：客户端 发送一个[FIN+ACK]，表示自己没有数据要发送了，想断开连接，并进入FIN_WAIT_1状态（不能再发送数据到服务端，但能够发送控制信息ACK到服务端）。 第二次挥手：服务端收到FIN后，知道不会再有数据从客户端传来，发送ACK进行确认，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态。 第三次挥手：服务端发送FIN给对方，表示自己没有数据要发送了，服务端进入LAST_ACK状态，然后直接断开TCP会话的连接，释放相应的资源。 第四次挥手：客户端收到了服务端对FIN的ACK后，进入FIN_WAIT2状态（等待服务端完成资源释放的一系列工作：然后释放你为创建这个连接所分配的资源，并通知我你关闭了）; 客户端收到了服务端的FIN信令后，进入TIMED_WAIT状态，并发送ACK确认消息。客户端在TIMED_WAIT状态下，等待2MSL一段时间，没有数据到来的，就认为对面已经收到了自己发送的ACK并正确关闭了进入CLOSE状态，自己也断开了到服务端的TCP连接，释放所有资源。当服务端收到客户端的ACK回应后，会进入CLOSE状态，并关闭本端的会话接口，释放相应资源。TIME_WAIT状态持续2MSL(MSL是数据分节在网络中存活的最长时间）。 网络上比较主流的文章都说关闭TCP会话是四次挥手，但是实际上为了提高效率通常合并第二、三次的挥手，即三次挥手。 关闭连接需要四次握手。 客户端向服务端发送FIN为1的报文，服务端返回确认，关闭客户端与服务端通信的部分。 服务端向客户端发送FIN为1的报文，客户端返回确认，关闭服务端与客户端通信的部分。 ","date":"2025-12-23","objectID":"/posts/9c9909b/:0:0","tags":["wireshark"],"title":"Wireshark","uri":"/posts/9c9909b/"},{"categories":["makedown"],"content":"Hugo 支持使用 Markdown 语法来格式化文本、创建列表等。本页将展示一些最常用的 Markdown 语法示例。 Markdown 示例 文档网页渲染实现pdf内嵌 Makedown文档本身无法实现pdf文档预览的功能，但是可以通过embed,网页渲染实现pdf文档预览 Go语言圣经 (Alan A. A. Donovan, Brian W. Kernighan etc.) (Z-Library).pdf \u003cembed src=\"https://example.com/document.pdf\" type=\"application/pdf\" width=\"100%\" height=\"800px\"\u003e 文本样式 样式 语法 示例 输出 粗体 **粗体文本** **粗体文本** 粗体文本 斜体 *斜体文本* *斜体文本* 斜体文本 删除线 ~~删除线文本~~ ~~删除线文本~~ 删除线文本 下标 \u003csub\u003e\u003c/sub\u003e 这是\u003csub\u003e下标\u003c/sub\u003e文本 这是下标文本 上标 \u003csup\u003e\u003c/sup\u003e 这是\u003csup\u003e上标\u003c/sup\u003e文本 这是上标文本 引用块 带出处的引用 不要通过共享内存来通信，而要通过通信来共享内存。 — Rob Pike1 Markdown \u003e 不要通过共享内存来通信，而要通过通信来共享内存。\u003cbr\u003e \u003e — \u003ccite\u003eRob Pike[^1]\u003c/cite\u003e [^1]: 上述引用摘自 Rob Pike 在 2015 年 11 月 18 日 Gopherfest 上的[演讲](https://www.youtube.com/watch?v=PAAkCSZUG1c)。 提示框 提示框是基于引用块语法的 Markdown 扩展，可用于强调关键信息。 支持 GitHub 风格的提示框。 请确保您使用的是最新版本的 Hextra 和 Hugo v0.146.0 或更高版本。 注意 即使用户只是浏览内容，也应该知道的有用信息。 提示 帮助用户更高效或更轻松完成任务的建议。 重要 用户需要了解的关键信息，以实现他们的目标。 警告 需要用户立即关注的紧急信息，以避免出现问题。 小心 关于某些操作可能带来风险或负面结果的警告。 \u003e [!NOTE] \u003e 即使用户只是浏览内容，也应该知道的有用信息。 \u003e [!TIP] \u003e 帮助用户更高效或更轻松完成任务的建议。 \u003e [!IMPORTANT] \u003e 用户需要了解的关键信息，以实现他们的目标。 \u003e [!WARNING] \u003e 需要用户立即关注的紧急信息，以避免出现问题。 \u003e [!CAUTION] \u003e 关于某些操作可能带来风险或负面结果的警告。 表格 表格不是 Markdown 核心规范的一部分，但 Hugo 原生支持它们。 姓名 年龄 张三 27 李四 23 Markdown | 姓名 | 年龄 | | :--- | :--- | | 张三 | 27 | | 李四 | 23 | 表格内的行内 Markdown 斜体 粗体 代码 斜体 粗体 代码 Markdown | 斜体 | 粗体 | 代码 | | :----- | :------- | :----- | | _斜体_ | **粗体** | `代码` | 代码块 语法高亮 列表 有序列表 第一项 第二项 第三项 Markdown 1. 第一项 2. 第二项 3. 第三项 无序列表 列表项 另一个项 再一个项 Markdown - 列表项 - 另一个项 - 再一个项 嵌套列表 水果 苹果 橙子 香蕉 乳制品 牛奶 奶酪 Markdown - 水果 - 苹果 - 橙子 - 香蕉 - 乳制品 - 牛奶 - 奶酪 任务列表 编写文档 代码审查 部署更改 Markdown - [x] 编写文档 - [ ] 代码审查 - [ ] 部署更改 图片 ![风景](https://picsum.photos/800/600) 带标题： Lorem Picsum Markdown ![风景](https://picsum.photos/800/600 \"Lorem Picsum\") 如需更高级的功能，请使用 Hugo 内置的 Figure 短代码。 配置 Hugo 使用 Goldmark 进行 Markdown 解析。 Markdown 渲染可以在 hugo.yaml 中的 markup.goldmark 下配置。 以下是 Hextra 的默认配置： hugo.yaml markup: goldmark: renderer: unsafe: true highlight: noClasses: false 更多配置选项，请参阅 Hugo 文档中的 配置 Markup。 学习资源 Markdown 指南 Markdown 速查表 Markdown 教程 Markdown 参考 ","date":"2025-12-21","objectID":"/posts/e7d8135/:0:0","tags":["makedown","pdf"],"title":"Markdown 语法示例","uri":"/posts/e7d8135/"},{"categories":["linux"],"content":"linux杂谈：一些常用命令 ##linux杂谈：一些常用命令 #查看内核版本 rpm -p kernel #删除....内核版本 dnf -y remove ....... #删除....内核版本 dnf remove --oldinstallonly --setopt installonly_limit=2 kernel #查看文本文件所在行 grep root /etc/passwd #执行如下命令可以设置一个新的系统时间： date -s \"20190712 18:30:50\" #执行如下命令将系统时间同步到硬件，防止系统重启后时间被还原。 hwclock --systohc #重启一下我们修改过的网卡，nmtui修改ip [root@7-2 ~]# nmcli connection up ens3 ens33 ens34 ens35 网卡无法启动 #用ifconfig查看，发现网卡不见了。用ifconfig -a查看，发现ens33网卡是在的，只是状态是down的。 #临时的解决方法： #使用ifconfig命令，直接启动ens33网卡 [root@centos7 ~]# ifconfig ens33 up #然后，临时配置一个IP地址 [root@centos7 ~]# ifconfig ens33 192.168.100.1 netmask 255.255.255.0 注意：此方法再虚拟机重启后失效。 RPM 包的常用操作命令 #1. 安装 rpm -ivh package.rpm：安装指定的 RPM 包，其中-i表示安装，-v表示显示详细信息，-h表示以哈希符号显示安装进度。 #2. 升级 rpm -Uvh package.rpm：升级指定的 RPM 包，如果系统中未安装该包，则会进行安装。-U选项用于升级操作。 #3. 卸载 rpm -e package：卸载指定的已安装软件包，-e表示卸载操作。 #4. 查询 rpm -qa：查询系统中已安装的所有 RPM 包。可以通过管道符|与grep命令结合使用，来查找特定的软件包。例如，rpm -qa | grep openssh可以查找系统中已安装的 OpenSSH 相关的 RPM 包。 rpm -qi package：查询指定软件包的详细信息，包括软件的描述、版本、依赖关系等。 rpm -ql package：查询指定软件包安装的文件列表，显示该软件包在系统中安装的所有文件及其路径。 SSH时出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! **翻译过来就是 警告：远程主机标识已更改！**ssh服务是通过公钥和私钥来进行连接的，它会把每个曾经访问过计算机或服务器的公钥（public key），记录在~/.ssh/known_hosts 中，当下次访问曾经访问过的计算机或服务器时，ssh就会核对公钥，如果和上次记录的不同，OpenSSH会发出警告。 使用命令清除所连接的IP ssh-keygen -R XX.XX.XX.XX vim/vi 文本编辑器 1）常用快捷键： (在一般模式下使用)： #在光标后一位开始插入 a #在该行的最后插入 A #在该行的最前面插入 I #直接跳到文件的首行 gg #直接跳到文件的末行 G #删除一行；3dd 删除3行；yy 复制一行；3yy 复制3行；p 粘贴；u：即undo撤销操作； dd #进入字符选择模式，选择完成后，按y复制，按p粘贴 v #进入块选择模式，选择完成后，按y复制，按p粘贴 ctrl+v #进入行选择模式，选择完成后，按y复制，按p粘贴 shift+v 2）查找并替换 1 显示行号 :set nu 2 隐藏行号：:set nonu 3 查找关键字 :/you ## 效果：查找文件中出现的you，并定位到第一个找到的地方，按n可以定位到下一个匹配位置(按N定位到上一个) 4 替换操作 ：s/sad/bbb 查找光标所在行的第一个sad，替换为bbb :%s/sad/bbb 查找文件中所有sad，替换为bbb head 显示文件内容头部 #查看文件头部的10行 head -10 install.log tail 显示文件内容尾部 tail -10 install.log 查看文件尾部的10行 tail +10 install.log 查看文件 10–\u003e末行 tail -f install.log 小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件 tail -F install.log 大F按照文件名来跟踪 windows永恒之蓝测试 在CMD窗口下，输入如下命令：netstat –ano | findstr “445”，找出相关进程号，其中SYN_SENT状态，很显然，该电脑被感染永恒之蓝病毒了 找出相关进程号对应的进程，在cmd下输入tasklist | findstr 20164，看看是哪个进程产生该数据包 打开任务管理器，找到相应的进程，先打开文件位置，然后结束进程 Cockpit 是什么具体解释： systemctl enable --now cockpit.socket 这条命令的作用是启用并立即启动 Cockpit Web 控制台的按需监听服务。 1. Cockpit 是什么？ Cockpit 是一个基于 Web 的 Linux 服务器管理界面 可通过浏览器（端口 9090）管理服务器：监控系统状态、管理服务、配置网络、查看日志等 2. cockpit.socket 的特殊性 这是 Socket 激活（Socket Activation） 方式 与传统服务不同： 普通服务：cockpit.service 会一直运行 Socket 服务：cockpit.socket 只监听端口，当有连接请求时才启动服务 3. 命令执行的具体效果： systemctl enable --now cockpit.socket enable：设置开机自动启动 --now：立即启动（无需重启系统） 结果： 系统开始监听 9090 端口 当用户通过浏览器访问时，才启动 cockpit 服务 空闲一段时间后，服务会自动停止（节省资源） 4. 与传统启动方式的对比： # Socket 方式（按需启动 - 推荐） systemctl enable --now cockpit.socket 5. 验证命令： # 查看 socket 状态 systemctl status cockpit.socket # 查看监听端口 ss -ltn | grep 9090 # 如果服务未按需启动，可检查 systemctl status cockpit.service 6. 访问方式： 浏览器访问：https://你的服务器IP:9090 使用系统账户密码登录 7. 关闭/禁用方法： # 停止并禁用 systemctl disable --now cockpit.socket # 如果 cockpit.service 已被激活运行，也需要停止 systemctl stop cockpit.service 优点：Socket 激活方式更节省资源，特别适合不经常使用的管理界面。 ubuntu拓荒指南 1.ubuntu上报E: Unable to locate package update错误的解决方法 #如果第一次使用系统，软件库缓存没有更新会包找不到软件包的错误。使用下面命令更新 sudo apt update #注意，上面的命令不是apt install，因为使用apt install，apt 包管理器会搜索缓存以获取包和版本信息，然后通##过网络从其存储库下载它。如果软件包不在此缓存中，系统将无法安装软件包。 新装系统，缓存是空的。首先应该运行 apt update 命令。这样就不会出现E: Unable to locate package 错误。 [ubuntu上报E: Unable to locate package update错误的解决方法 – 知乎](https://zhuanlan.zhihu.com/p/484067483#:~:text=ubuntu上报E%3A Unable to locate package update错误的解决方法 1 1.检查软件包名名称：,4. 检查 Ubuntu 版本的活跃程度 Ubuntu 有两种主要的版本。 常规版本支持九个月，而长期支持版本支持五年。) 2.ubuntu使用ping命令未发现 Sudo apt-get install iputils-ping ","date":"2025-12-18","objectID":"/posts/835784b/:0:0","tags":["linux"],"title":"linux杂谈：一些常用命令","uri":"/posts/835784b/"},{"categories":["linux","windows"],"content":"windows入侵排查，Linux入侵排查流程 windows入侵排查 一、检查系统账号安全 攻击者面对windows系统会先从用户密码入手，首先是通过rdp服务对Administrator、Guest等默认账户的口令爆破，如果爆破没结果的话会固定密码，对用户账号进行爆破，再之后加入还是失败的话就是社工生成账号、密码字典，运气好那么就可以直接登录到管理员账号。在拿到系统权限后，权限维持则是必不可少的一步，创造一个新的管理账号方便后期登录查看就是一个不错的方法，当然为了增加隐蔽性该账号可以是影子账户。根据这几方面，检查看系统账号时可以重点关注弱口令、可疑账号、影子账户。 二、检查异常端口、进程 端口作为计算机内部与外部数据交互的窗口，在攻击者眼里也是作为香饽饽的存在，在入侵系统后，攻击者可以在计算机上开启专属的端口来访问被害主机或植入病毒用于挖矿等，熟悉计算机的朋友应该都知道常用的端口也就那么几个，所以通过排查可疑端口能确定主机是否存在后门、是否被植入挖矿病毒等，再根据端口的PID对可疑进程对应的程序排查，确定是否为恶意程序。 （一）排查可疑端口 检查方法1： 1、使用netstat命令查看当前网络连接，定位可疑的ESTABLISHED连接 netstat -ano 2、根据PID编号通过tasklist对进程进行定位 tasklist ｜ findstr “PID” https://i-blog.csdnimg.cn/blog_migrate/6fb83ac09fbafdaa66a0c8e1c83e3328.png （二）排查可疑进程 检查方法1： 1、在桌面打开运行（可使用快捷键 win+R），输入 msinfo32 命令 2、依次点击 “软件环境 — 正在运行任务” 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等。 三、检查启动项、计划任务和服务 启动项、计划任务、服务是攻击者维持权限的惯用手段。在入侵windows计算机后，攻击者可以通过修改注册表、替换粘滞键程序在系统启动时就获得权限，也能够在管理员权限下设置计划任务，因为计划任务后门分为管理员权限和普通用户权限两种。管理员权限可以设置更多的计划任务，例如重启后运行等。也可以通过meterpreter创建后门服务。 （一）排查异常启动项 检查方法1： 单击【开始】\u003e【所有程序】\u003e【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。 检查方法2： 在桌面打开运行（可使用快捷键 win+R），输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。 检查方法3: 在桌面打开运行（可使用快捷键 win+R），输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项： HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce 检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。 （二）排查计划任务 检查方法1： 1、在桌面打开运行（可使用快捷键 win+R），输入 control 打开控制面板 2、在 系统与安全 中查看计划任务属性，便可以发现木马文件的路径。 检查方法2： 1、在桌面打开运行（可使用快捷键 win+R），输入 cmd 打开命令行窗口 2、检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接，其中计划任务在windows7及之前版本的操作系统中使用at命令进行调用，在从windows8版本开始的操作系统中使用schtasks命令调用。 windows server 2016 下执行 schtasks （三）排查服务自启动 检查方法： 1、在桌面打开运行（可使用快捷键 win+R），输入 services.msc 2、注意服务状态和启动类型，检查是否有异常服务 四、检查系统相关信息 系统本身如果存在漏洞，那么结果往往是致命的，如果计算机存在永恒之蓝漏洞且未采取防护措施。那么攻击者就能直接通过MSF的漏洞利用程序获取目标windows系统的system权限。与此同时，攻击者在进入系统后往往也会留一些蛛丝马迹，如未将上传文件清除、浏览器浏览记录未删除、下载的文件未删除等。在检查系统相关信息时就需要重点关注系统本身存在的漏洞以及攻击者使用过的文件。 （一）查看系统版本以及补丁信息 检查方法： 1、在桌面打开运行（可使用快捷键 win+R）输入 systeminfo 2、查看系统信息和补丁状态 （二）查看可疑目录及文件 检查方法1： 查看用户目录，是否存在新建用户目录 Window 2003版本 : C:\\Documents and Settings Window 2003以后版本 : C:\\Users\\ 检查方法2： 1、在桌面打开运行（可使用快捷键 win+R）输入 %UserProfile%\\Recent 2、分析最近打开的可疑文件 检查方法3： 1、点击文件资源管理器，查找服务器内中的各个文件夹 2、将文件夹文件按时间进行排序，查找可疑文件，其中修改时间在创建时间之前的为可疑文件，也可以在搜索中搜索某一时间修改的文件。重点关注windows\\system32的sethc.exe是否被替换为cmd程序 检查方法4： 针对回收站、浏览器下载目录以及历史记录进行排查 （三）查看隐藏文件 检查方法1： 1、在桌面打开运行（可使用快捷键 win+R），输入 control，进入控制面板 2、找到文件资源管理器选项，点击 查看 后，取消”隐藏受保护的操作系统文件“勾选，在隐藏文件和文件夹下面的单选选择显示隐藏的文件、文件夹和驱动器 （四）日志分析 主要查看系统日志和web日志，通过日志可以帮助我们验证对入侵过程的判断和发现其他入侵行为。但它的前提则是日志记录已开启的情况下才能获取。这块具体会在之后的日志分析篇提到 （一）系统日志 分析方法： 1、在桌面打开运行（可使用快捷键 win+R），输入 eventvwr.msc 2、找到事件查看器，查看windows日志（包括应用程序、安全、Setup、系统、事件） （二）web日志 分析方法： 1、找到中间件、应用、WAF的日志（包括但不限于IIS、Nginx、宝塔、网站等） 2、打包至本地进行分析，在编辑器中对关键字进行搜索 使用日志分析工具进行分析异常 总结： 检查系统账号—-\u003e检查异常端口、进程netstat -ano，tasklist ｜ findstr “PID”， msinfo32系统信息—-\u003e检查启动项、计划任务和服务,msconfig启动项，services.msc服务—-\u003e检查系统相关信息systeminfo系统信息,eventvwr.msc系统日志 ##检查系统账号，检查异常端口、进程 netstat -ano，tasklist ｜ findstr “PID” ##系统信息—-\u003e检查启动项、计划任务和服务 msinfo32 ##启动项 msconfig ##服务 services.msc ##检查系统相关信息 systeminfo ##系统日志 eventvwr.msc 端口状态 LISTENING、ESTABLISHED、TIME_WAIT及CLOSE_WAIT详解，以及三次握手，滑动窗口_established状态-CSDN博客 终于搞懂了 TCP 的 11 种状态 ，太不容易了… – 腾讯云开发者社区-腾讯云 (tencent.com) Linux入侵排查流程 查看用户信息文件,是否存在新增用户 cat /etc/passwd 查看 /home目录是否有新目录(如果存在可疑目录,可能被入侵) 查看是否还有其他特权用户(默认只有一个特权用户 root 即uid=0) awk -F: '$3==0{print $1}' /etc/passwd 查看当前登录用户 who # tty：本地登录 pts：远程登录 查看系统信息 w #可以知道某一时刻用户的行为 查看的用户的多少，用户上线了多久，以及负载 uptime 删除用户密码 passwd -d username 查看用户上一次密码修改时间 stat /etc/passwd #如果近期修改过，可能存在问题 查看不可登录之外的用户 cat /etc/passwd | grep -v nologin #有无新增用户，有则可能存在问题 查看具有root权限的用户 cat /etc/passwd | grep x:0 # 有新增的就可能存在问题 查看使用shell的用户 cat /etc/passwd | grep /bin/bash 查看具有sudo权限的用户 more /etc/sudoers | grep -v \"^#\\|^$\" | grep \"ALL=(ALL)\" 查看登录失败的次数 grep -o \"Failed password\" /var/log/secure|uniq -c 查看登录失败的用户 lastb 查看登录使用的用户名 （可以看到出现的次数） grep \"Failed password\" /var/log/secure|perl ","date":"2025-12-17","objectID":"/posts/51fa418/:0:0","tags":["linux","windows常用命令","入侵排查"],"title":"Windows与Linux入侵排查","uri":"/posts/51fa418/"},{"categories":["网络安全"],"content":"Nmap常用操作及参数 nmap -O -sV 192.168.1.1 #扫描系统版本信息和服务版本信息， #要扫描单个服务信息（如web）使用nmap -sV -p 80 192.168.1.1 #扩展 以下是常用参数： -O：激活操作探测； -P0：只进行扫描，不ping主机； -PT：同TCP的ping； -sV：探测服务版本信息； -sP：ping扫描，仅发现目标主机是否存活； -ps：发送同步（SYN）报文； -PU：发送udp ping； -PE：强制执行直接的ICMPping； -PB：默认模式，可以使用ICMPping和TCPping； -6：使用IPv6地址； -v：得到更多选项信息； -d：增加调试信息的输出； -oN：以人们可阅读的格式输出； -oX：以xml格式向指定文件输出信息； -oM：以机器可阅读的格式输出； -A：使用所有高级扫描选项； -P：指定要扫描的端口，可以是一个单独的端口，用逗号隔开多个端口，使用“-”表示端口范围； -e：在多网络接口Linux系统中，指定扫描使用的网络接口； -g：将指定的端口作为源端口进行扫描； –resume：继续上次执行完的扫描； –ttl：指定发送的扫描报文的生存期； –packet-trace：显示扫描过程中收发报文统计； –scanflags：设置在扫描报文中的TCP标志。 Nmap简单的扫描方式 #全面扫描：nmap -T4 -A ip #主机发现：nmap -T4 -sn ip #端口扫描：nmap -T4 ip #服务扫描：nmap -T4 -sV ip #操作系统扫描：nmap -T4 -O ip 1、SYN扫描 首先可以利用基本的SYN扫描方式探测其端口开放状态。 nmap -sS -T4 www.fujieace.com #扫描输出结果为： All 997 ports are filtered PORT STATE SERVICE 80/tcp open http 113/tcp closed auth 507/tcp open crs 我们可以看到SYN方式探测到3个端口开放，而有997个端口被过滤。Nmap默认扫描只扫描1000个最可能开放的端口，如果想扫描全部的端口，命令如下： nmap -sS -T4-p- www.fujieace.com 2、FIN扫描 然后可以利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态。 nmap -sF -T4 www.fujieace.com #扫描输出结果为： PORT STATE SERVICE 7/tcp open|filtered echo 9/tcp open|filtered discard 11/tcp open|filtered systat 13/tcp open|filtered daytime 23/tcp open|filtered telnet 25/tcp open|filtered smtp 37/tcp open|filtered time 79/tcp open|filtered finger 80/tcp open|filtered http 更多端口，此处省略……. 3、ACK扫描 然后利用ACK扫描判断端口是否被过滤。针对ACK探测包，未被过滤的端口（无论打开、关闭）会回复RST包。 nmap -sA -T4 www.fujieace.com #扫描输出结果为： Not shown: 997 unfiltered ports PORT STATE SERVICE 135/tcp filtered msrpc 1434/tcp filtered ms-sql-m 32777/tcp filtered sometimes-rpc17 从结果可以知道997个端口是未被过滤的（unfiltered），而3个（135/1434/32777）被过滤了。所以，将ACK与FIN扫描 的结果结合分析，我们可以找到很多开放的端口。例如7号端口，FIN中得出的状态是:open或filtered，从ACK中得出的状态是 unfiltered，那么该端口只能是open的。 4、Window扫描 当然也可以利用Window扫描方式，得出一些端口信息，可以与之前扫描分析的结果相互补充。Window扫描方式只对某些TCPIP协议栈才有效。 window扫描原理与ACK类似，发送ACK包探测目标端口，对回复的RST包中的Window size进行解析。在某些TCPIP协议栈实现中，关闭的端口在RST中会将Window size设置为0；而开放的端口将Window size设置成非0的值。 nmap -sW -p- -T4 www.fujieace.com 输出结果： PORT STATE SERVICE 7/tcp open echo 9/tcp open discard 11/tcp open systat 13/tcp open daytime 更多端口，此处省略…… 在采用多种 扫描路由器操作系统 nmap -O -F -n 192.168.1.1 与通用PC扫描方式类似，使用-O选项扫描路由器的操作系统。-F用于快速扫描最可能开放的100个端口，并根据端口扫描结果进一步做OS的指纹分析方式获取出防火墙状态后，可以进一步进行应用程序与版本侦测及OS侦测。 nmap [扫描目标] [选项] v: 增加输出的详细程度。 A: 启用OS检测、版本检测、脚本扫描和traceroute。 p:指定要扫描的端口范围，例如p 1-100。 Nmap实战 1.扫描局域网中存活的主机 举个栗子假设我自己的网络是在192.168.88.0网段，就可以使用以下命令进行ping探测。 nmap -sP 192.168.88.* #或者 nmap -sP 192.168.88.0/24 nmap -sP 192.168.88.* 或者nmap -sP 192.168.88.0/24 2.怎么看我的网段 按住win键+R键打开运行窗口 在运行窗口输入cmd回车，打开cmd命令行 输入ipconfig就可以查看到自己的ip地址了哦 3.Nmap扫描目标开放的端口和识别服务版本 举个栗子上面扫描时发现好几个ip地址，先扫描个192.168.88.14看看。 nmap -sV 192.168.88.1 Nmap高级篇 1.探查目标服务详细信息并使用相关脚本进行扫描，展示更多的信息。 nmap -A 192.168.88.14 2.nmap脚本引擎 nmap的脚本默认目录为：/usr/share/nmap/scripts/ 类别 解释 auth 负责处理鉴权证书（绕开鉴权）的脚本 broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 brute 提供暴力破解方式，针对常见的应用如http/snmp等 default 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力 discovery 对网络进行更多的信息，如SMB枚举、SNMP查询等 dos 用于进行拒绝服务攻击 exploit 利用已知的漏洞入侵系统 external 利用第三方的数据库或资源，例如进行whois解析 fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive:入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 malware 探测目标机是否感染了病毒、开启了后门等信息 safe 此类与intrusive相反，属于安全性脚本 version 负责增强服务与版本扫描（Version Detection）功能的脚本 vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 举个栗子使用vuln模块进行常见漏洞检测（会有点慢）： nmap –script vuln 192.168.88.14 3.防火墙逃逸，绕过防火墙扫描。 报文分段法： #报文分段法： nmap -f -v 192.168.88.14 在Nmap使用-f选项时会将TCP头分段在几个包中，使得包过滤器、IDS以及其他工具的检测更加困难。Nmap在IP头后会将包分为8个字节或更小。 一些主机会禁止相应ICMP请求，对于这种情况就可以使用报文分段的方法来逃避目标防火墙的规则。 指定报文大小： #指定报文大小 nmap –mtu 16 192.168.88.14 此值设定TCP/IP协议传输数据报时的最大传输单元。使用指定MTU可以达到逃逸防火墙/IDS的目的，需要注意的是偏移量必须是8的倍数。 指定发包长度: #指定发包长度 nmap –data-length 30 192.168.88.14 通常情况下，TCP包是40个字节，ICMP Echo 有28个字节，所以在原来的报文基础上附加随机数据达到规避防火墙的效果。 4.探测目标防火墙规则 nmap –script=firewalk –traceroute 192.168.88.14 nmap –script=firewalk –traceroute 192.168.88.14 在Nmap的firewalk脚本通过发送一个请求并分析TTL值，可以探测防火墙的规则。 5.VMWare认证破解 nmap -p 902 –script vmauthd-brute 192.168.88.14 Nmap中的vmauthd-brute脚本可以破解安装虚拟机系统","date":"2025-12-17","objectID":"/posts/d59e8d0/:0:0","tags":["Nmap"],"title":"Nmap常用操作","uri":"/posts/d59e8d0/"},{"categories":["linux"],"content":"一，跑字典，暴力穷举 *aircrack-ng破解wifi密码* IYATT-yx/WiFi-Password-Dictionary: WiFi 密码字典 (github.com) aircrack-ng破解wifi密码【黑客渗透测试零基础入门必知必会】-CSDN博客 *wifi-crack-tool WiFi密码暴破工具 wifi破解* wifi-crack-tool WiFi密码暴破工具 wifi破解 – 🔰雨苁ℒ🔰 (ddosi.org) 爆破方案 1.连接尝试：https://blog.iyatt.com/?p=10615 这种方案速度较慢，相当于一个一个去连接尝试 2.抓包匹配：https://blog.iyatt.com/?p=10677 锁定目标 WiFi 扫描，攻击干扰 WiFi 让处于连接状态的设备断开，设备尝试重新连接时会发送包含加密密码的握手包，抓取这个握手包，再用字典中的密码尝试按照相同方式加密去匹配，速度完虐方案 1。 二，钓鱼 主要原理： *创建一个伪AP来“狸猫换太子”，然后撤销用户AP的授权，* *通知用户需要进行“固件升级”，需要重新验证密码。你的假AP由于具有相同的SSID，用户便会“交代”密码。* *这样你就能得到用户的密码，并且让用户采用你的伪AP做为自己的接入点。而对方一无所知。* 四步教你破解隔壁老王的Wi-Fi密码，蹭网没商量！_分分钟解开邻居家的wifi-CSDN博客 渗透测试之地基服务篇：无线攻防之钓鱼无线攻击（上） – FreeBuf网络安全行业门户 Lindset的高级社会工程攻击演变而来，Fluxion的操作简单只需要选择你需要钓的鱼其他的你基本就不用管了。 工作原理： 1、扫描网络 2、捕获握手（不能没有有效的握手使用，需要验证密码） 3、使用WEB界面 4、启动 FakeAP 实例来模拟原始接入点 5、生成一个 MDK3 进程，该进程使所有已经连接到目标网络的用户连接失效，然后引诱他们连接到 FakeAP 并输入 WPA 的密码 6、启动一个虚假的 DNS 服务器，抓取所有的 DNS 请求并将其重定向到运行该脚本的主机 7、启动强制访问的网站页面，并提示用户输入他们的 WPA 密码 8、每个提交的密码都通过之前捕获的握手进行验证 9、只要提交了正确的密码，攻击就会自动终止 Wifi钓鱼工具——fluxion – freeliver – 博客园 (cnblogs.com) （Kali Linux和两个无线适配器，其中一个必须能支持数据包注入。） ","date":"2025-12-17","objectID":"/posts/bb6cad8/:0:0","tags":["wifi","密码破解"],"title":"wifi密码破解分析的几种常见方式","uri":"/posts/bb6cad8/"},{"categories":["linux"],"content":"ssh 利用非对称加密实现安全的登录 非对称加密中有两个密钥：公钥和私钥。公钥由私钥产生，但却无法推算出私钥；公钥加密后的密文，只能通过对应的私钥来解密。 终端要登录 Server 服务器，发起登录请求 ssh work@server.com。服务端运行有 sshd 服务，并监听指定的端口，默认为 22 号端口。 服务端会生成一对公钥和私钥；此时将公钥返回给客户端；客户端使用公钥，对登录密码进行加密（如服务器work用户密码为xxx），生成公钥加密字符串；客户端将公钥加密字符串发送给服务端；服务端使用私钥，解密公钥加密字符串，得到原始密码；校验密码是否合法（此为本机 work 密码）；返回登录结果给客户端：成功登录或密码错。 在非对称加密中，由于只有公钥会被传输，而私钥是服务端本地保存，因此即便公钥被监听，也无法拿到原始密码，从而安全地登录服务器。 使用指定用户名和端口登录远程主机。ssh -p3600 root@9.134.114.170 SSH 服务的配置文件 通常位于 /etc/ssh/sshd_config。可以使用文本编辑器编辑该文件以调整设置。常见配置选项包括： Port：指定 SSH 服务监听的端口（默认为 22）。Port 22 PermitRootLogin：控制是否允许 root 用户通过 SSH 登录。出于安全考虑，通常建议设置为 no。 PermitRootLogin no PasswordAuthentication：控制是否允许密码认证。启用密钥认证时，可以将此选项设置为 no。 PasswordAuthentication yes AllowUsers 和 DenyUsers：控制允许和拒绝登录的用户。AllowUsers user1 user2 ## 修改配置文件后，使用以下命令重启 SSH 服务使更改生效：sudo systemctl restart ssh 通过 ssh 实现免密登录。 免密登录的实现过程如下： 1.在客户端使用 ssh-keygen 生成一对密钥：公钥+私钥；`` 2.将客户端公钥追加到服务端的 authorized_key 文件中，完成公钥认证操作； 3.认证完成后，客户端向服务端发起登录请求，并传递公钥到服务端； 4.服务端检索 authorized_key 文件，确认该公钥是否存在。如果存在该公钥，则生成随机数 R，并用公钥进行加密，生成公钥加密字符串 pubKey(R)； 5.将公钥加密字符串传递给客户端； 6客户端使用私钥解密公钥加密字符串，得到 R； 7.服务端和客户端通信时会产生一个会话 ID(sessionKey)，用 MD5 对 R 和 SessionKey 进行加密，生成摘要； 8.客户端将生成的 MD5 加密字符串传给服务端； 9.服务端同样生成 MD5(R,SessionKey) 加密字符串； 10.如果客户端传来的加密字符串等于服务端自身生成的加密字符串，则认证成功。此时不用输入密码，即完成建连，可以开始远程执行 Shell 命令了。 ##第一步使用 ssh-keygen 命令在客户端生成 RSA 公钥和私钥，一直回车确认。公钥和私钥默认名称为 id_rsa.pub（公钥）和私钥（id_rsa），默认保存在 ~/.ssh/目录下。 ssh-keygen -t rsa ##第二步将客户端公钥追加至服务端 ~/.ssh/authorized_keys 文件中，authorized_keys 是用来存放客户端公钥的文件。 ##有三种方法， #一是通过 ssh-copy-id 命令， #例如使用 ssh-copy-id 命令实现如下 ssh-copy-id -i ~/.ssh/id_rsa.pub -p 3600 root@9.134.114.170 #二是通过 scp 命令， #三是手动复制。 ##第三步使用 ssh 进行免密登录。 ssh -p3600 root@9.134.114.170 端口转发 SSH 支持端口转发功能，可以将本地端口转发到远程主机，或将远程端口转发到本地。 例如：本地端口转发：将本地端口 8080 转发到远程主机的 80 端口。 ssh -L 8080:localhost:80 user@example.com 远程端口转发：将远程主机的 8080 端口转发到本地的 80 端口。 ssh -R 8080:localhost:80 user@example.com 动态端口转发：使用 SOCKS 代理将本地端口转发到远程主机。ssh -D 1080 user@example.comSSH 配置文件可以在 ~/.ssh/config 文件中配置 SSH 客户端的选项，以简化连接。例如： Host myserver HostName example.com User myuser Port 2222 IdentityFile ~/.ssh/id_rsa 这样，可以使用简化的命令连接： ssh myserver 删除或更改私钥上的密码 如果您已经为您的私钥生成了密码并希望更改或删除它，您可以轻松地做到这一点。 注意：要更改或删除密码，您必须知道原始密码。如果您丢失了密钥的密码短语，则没有追索权，您将不得不生成一个新的密钥对。 要更改或删除密码，只需键入： ssh-keygen -pEnter file in which the key is (/root/.ssh/id_rsa): #您可以键入要修改的键的位置或按 ENTER 接受默认值： Enter old passphrase: 输入您要更改的旧密码。然后系统会提示您输入新密码： Enter new passphrase (empty for no passphrase): Enter same passphrase again: 在这里，输入您的新密码或按 ENTER 删除密码。 ","date":"2025-12-17","objectID":"/posts/de36ed4/:0:0","tags":["ssh常见操作","ssh"],"title":"ssh常见配置和操作命令","uri":"/posts/de36ed4/"},{"categories":["linux"],"content":"make install与rpmbuild -ba openssh.spec的区别特点 编译过程和依赖管理 make install 通常用于从源代码直接编译和安装软件。在执行make install之前，需要先运行./configure脚本进行配置，该脚本会检查系统环境和依赖关系，然后生成相应的 Makefile。在编译过程中，make命令会根据 Makefile 中的规则来编译源代码，并最终通过make install将编译好的文件安装到指定的系统目录中。 这种方式在处理依赖关系时相对较为简单直接。它主要依赖于configure脚本检查系统中是否存在所需的库和工具，如果缺少依赖，configure脚本通常会报错，提示用户需要安装哪些软件包来满足依赖关系。然而，它可能无法像 RPM 包那样精确地管理依赖关系，例如，对于一些可选的依赖，如果系统中没有安装，可能会导致软件的某些功能无法正常使用，但编译过程可能仍然可以继续进行。 rpmbuild -ba openssh.spec 是基于 RPM 包构建系统的一种方式。rpmbuild命令用于构建 RPM 包，-ba选项表示同时构建二进制 RPM 包和源代码 RPM 包。openssh.spec是一个规范文件，它包含了关于如何构建 OpenSSH RPM 包的详细信息，如软件的版本、源文件列表、编译选项、依赖关系等。 在构建 RPM 包的过程中，rpmbuild会严格按照openssh.spec文件中定义的依赖关系来检查系统中是否安装了所需的软件包。如果缺少依赖，rpmbuild会明确指出并停止构建过程，直到所有依赖都被满足。这使得 RPM 包在依赖管理方面更加严格和精确，能够确保软件在安装和运行时具有完整的依赖环境，减少因依赖问题导致的软件故障。 安装和升级管理 make install 执行make install命令后，软件会被直接安装到系统指定的目录中，通常会覆盖原有的同名文件（如果存在）。在升级软件时，需要重新获取最新的源代码，重新运行./configure、make和make install命令，这可能会导致之前的配置文件被覆盖，需要用户手动备份和恢复重要的配置信息。 这种方式的优点是安装过程相对简单直接，用户可以对编译和安装过程有更多的控制，例如可以根据自己的需求定制编译选项。但缺点是升级过程较为繁琐，容易出现配置丢失或不兼容的问题。 rpmbuild -ba openssh.spec 构建好 RPM 包后，可以使用rpm命令进行安装、升级和卸载操作。例如，使用rpm -Uvh openssh-\u003cversion\u003e-\u003crelease\u003e.x86_64.rpm命令可以升级已安装的 OpenSSH 软件包。在升级过程中，RPM 包管理系统会自动处理文件的替换和备份，保留用户的配置文件（通常会将原配置文件重命名为.rpmnew或.rpmsave等后缀，以便用户在需要时进行恢复），确保升级过程的平滑性和稳定性。 RPM 包的安装和升级操作相对更加标准化和自动化，易于管理和维护。同时，RPM 包管理系统还提供了版本管理和依赖检查等功能，使得软件的安装和升级更加可靠和安全。 软件包格式和可移植性 make install 从源代码直接编译安装后，软件文件会分散安装到系统的各个目录中，没有形成一个统一的软件包格式。这使得软件的备份、迁移和分发相对较为困难，因为需要手动复制和管理多个文件和目录，并且可能需要重新配置软件在新的环境中的运行参数。 由于不同系统的目录结构和环境设置可能存在差异，从源代码编译安装的软件在可移植性方面相对较差。在一个系统上编译安装成功的软件，在其他系统上可能需要重新编译和配置才能正常运行。 rpmbuild -ba openssh.spec RPM 包是一种标准化的软件包格式，它将软件的所有文件、元数据（如软件名称、版本、描述、依赖关系等）以及安装脚本等打包成一个文件。这使得 RPM 包易于备份、迁移和分发，可以方便地在不同的系统之间共享和安装。 RPM 包具有较好的可移植性，因为它在构建过程中已经考虑了不同系统之间的差异，并且可以通过软件仓库进行集中管理和分发。只要目标系统安装了相应的 RPM 包管理系统，就可以方便地安装和运行 RPM 包，而无需重新编译源代码。 系统集成和维护 make install 从源代码编译安装的软件可能无法与系统的包管理系统和服务管理机制进行很好的集成。例如，在一些基于 systemd 的系统中，通过make install安装的软件可能不会自动在 systemd 中注册服务，需要用户手动创建和配置相应的服务单元文件。 在系统维护方面，由于没有统一的软件包管理机制，对于软件的更新、卸载和故障排查可能会更加困难。用户需要手动跟踪软件的更新情况，并手动执行相应的操作来维护软件的运行环境。 rpmbuild -ba openssh.spec RPM 包与系统的集成度较高，安装的软件会自动在系统的包管理系统中注册，可以方便地使用系统提供的工具进行管理，如rpm命令用于查询、安装、升级和卸载软件包，systemctl命令用于管理 RPM 包安装的服务等。 在系统维护方面，RPM 包管理系统提供了方便的维护机制，如可以通过软件仓库自动获取软件的更新，并且在卸载软件时会自动清理相关的文件和目录，减少系统中的残留文件和垃圾数据。 综上所述，make install和rpmbuild -ba openssh.spec两种编译方式在编译过程、依赖管理、安装升级、软件包格式、可移植性以及系统集成和维护等方面都存在一定的区别。在实际应用中，可以根据具体的需求和场景选择合适的编译和安装方式。如果需要对软件进行高度定制化编译，或者希望对编译过程有更多的控制，那么make install可能是一个不错的选择；如果注重软件包的管理和维护的便利性、可移植性以及依赖关系的精确管理，那么使用rpmbuild构建 RPM 包并进行安装的方式可能更为合适。 RPM（Red Hat Package Manager）包 在 Linux 系统中，使用 RPM（Red Hat Package Manager）包进行安装的基本命令是rpm。 以下是一些常见的使用方式： ### 1. 安装 RPM 包 “`bash rpm -ivh package.rpm “` – `-i`表示安装（install）。 – `-v`表示显示详细信息（verbose）。 – `-h`表示以哈希符号显示安装进度（hash）。 例如： rpm -ivh apache-httpd-2.4.57-1.el7.centos.x86_64.rpm ### 2. 升级 RPM 包 “`bash rpm -Uvh package.rpm “` – `-U`表示升级（upgrade）。如果系统中没有安装该包，则会进行安装操作，相当于先卸载旧版本再安装新版本。 例如： “`bash rpm -Uvh openssh-clients-8.4p1-1.el8.x86_64.rpm “` ### 3. 查看已安装的 RPM 包信息 “`bash rpm -qi package_name “` – `-q`表示查询（query）。 – `-i`表示显示软件包的详细信息，包括名称、版本、描述等。 例如： “`bash rpm -qi firefox “` ### 4. 查看 RPM 包安装的文件列表 “`bash rpm -ql package_name “` – `-q`表示查询。 – `-l`表示列出（list）安装的文件 。 例如： “`bash rpm -ql httpd “` ### 5. 验证 RPM 包的完整性 “`bash rpm -V package_name “` – `-V`表示验证（verify）。如果没有输出，则表示包的完整性没有问题；如果有输出，则表示包中的某些文件被修改、删除或存在其他问题。 例如： “`bash rpm -V apache-httpd “` ### 6. 卸载 RPM 包 “`bash rpm -e package_name “` – `-e`表示卸载（erase）。 例如： “`bash rpm -e samba-client “` 在使用rpm命令时，需要注意权限问题，通常需要以管理员权限（root 用户或使用sudo）来执行安装、升级和卸载操作。同时，RPM 包可能存在依赖关系，如果安装过程中提示缺少依赖包，需要先安装依赖包再安装目标包。 ","date":"2025-12-17","objectID":"/posts/3d7214d/:0:0","tags":["编译","RPM","make"],"title":"编译过程和依赖管理，RPM（Red Hat Package Manager）\u0026\u0026 make install常见的使用方式","uri":"/posts/3d7214d/"},{"categories":["linux"],"content":"在Linux系统使用中，我们经常需要下载文件、对文件进行压缩和解压操作。 本文将介绍一些常用的Linux命令，帮助你轻松完成这些操作。 1.文件下载 1.1 wget命令 wget命令是Linux中最常用的下载命令之一。它支持HTTP、HTTPS、FTP等多种协议，并可以设置断点续传等功能。 基本用法: wget [选项] URL地址 常用选项: -c: 断点重连，继续下载未完成的文件。 -O: 指定下载文件的保存名称。 -P: 指定下载文件的保存路径。 -q: 静默模式，不显示下载进度。 # 下载文件并保存为默认名称 wget https://www.example.com/file.txt # 下载文件并保存为默认名称，-c为断点重连，如果断网后，下次会接续 wget -c https://www.example.com/file.txt # 下载文件并指定保存名称 wget -O myfile.txt https://www.example.com/file.txt # 下载文件并指定保存路径 wget -P /tmp https://www.example.com/file.txt # 静默模式下载文件 wget -q https://www.example.com/file.txt wget还有许多其他的选项，可以通过man wget或wget help查看。 1.2 curl命令 curl命令也是一个常用的下载命令，它支持的功能与wget类似。 基本用法: curl [选项] URL地址 常用选项: -o: 指定下载文件的保存名称。 -L: 跟踪重定向。 -s: 静默模式，不显示下载进度。 # 下载文件并保存为默认名称 curl https://www.example.com/file.txt # 下载文件并指定保存名称 curl -o myfile.txt https://www.example.com/file.txt # 跟踪重定向并下载文件 curl -L https://www.example.com/redirect.html # 静默模式下载文件 curl -s https://www.example.com/file.txt curl还有许多其他的选项，可以通过man curl 或则 curl help查看 2.文件压缩 2.1 gzip命令 gzip命令是Linux中最常用的压缩命令之一，它可以对文件进行 gzip 压缩格式的压缩。 基本用法: gzip [选项] 文件名 常用选项: -c: 压缩后不删除源文件。 -d: 解压缩文件。 -f: 强制压缩文件，即使文件已存在。 -9: 使用最高压缩级别。 # 压缩文件 gzip file.txt # 解压缩文件 gzip -d file.txt.gz # 强制压缩文件 gzip -f file.txt # 使用最高压缩级别压缩文件 gzip -9 file.txt 2.2 bzip2命令 bzip2命令也是一个常用的压缩命令，它可以对文件进行 bzip2 压缩格式的压缩。 基本用法: bzip2 [选项] 文件名 常用选项: -c: 压缩后不删除源文件。 -d: 解压缩文件。 -f: 强制压缩文件，即使文件已存在。 -9: 使用最高压缩级别。 # 压缩文件 bzip2 file.txt # 解压缩文件 bzip2 -d file.txt.bz2 # 强制压缩文件 bzip2 -f file.txt # 使用最高压缩级别压缩文件 bzip2 -9 file.txt 3.文件解压 3.1 tar命令 tar命令是Linux中常用的解压命令，它可以解压 tar 格式的压缩包。 基本用法: tar [选项] 文件名 常用选项: -c: 创建压缩包。 -x: 解压缩文件。 -f: 指定压缩包文件名。 -v: 显示详细信息。 # 解压缩文件 tar -xvf file.tar.gz # 解压缩文件并显示详细信息 tar -xvzf file.tar.gz # 创建压缩包 tar -cf myfile.tar file1 file2 3.2 unzip命令 unzip命令是Linux中常用的解压命令，它可以解压 zip 格式的压缩包。 基本用法: unzip [选项] 文件名 常用选项: -d: 指定解压文件的保存路径。 -l: 查看压缩包内容。 -q: 静默模式，不显示解压进度。 # 解压缩文件 unzip file.zip 本文介绍了Linux中三个常用的命令：wget、gzip和tar，分别用于文件的下载、压缩和解压。这些命令都有很多的选项，可以根据不同的需求进行调整。通过掌握这些命令，我们可以更方便地管理和处理文件。希望本文对你有所帮助。 ","date":"2025-12-17","objectID":"/posts/68ced8b/:0:0","tags":["wget","curl","gzip","bzip","tar","unzip"],"title":"Linux文件下载以及进行压缩和解压","uri":"/posts/68ced8b/"},{"categories":["linux"],"content":"在我们登入终端后，会弹出一段欢迎信息，上面会显示登录主机的信息。通过修改 Motd 文件，我们可以修改SSH终端欢迎信息。 原理 在类 Unix 系统中，/etc/motd 是一个包含“今日消息”（Message of the day）的文件。 比起电子邮件，使用 Motd 给所有用户发送消息显得更有效率。其它操作系统中也可能有这一功能，比如 Multics 中的 Motd 信息分段。 /etc/motd 内容的会在用户成功登录后由 Unix 登录命令显示，整个过程发生在 Shell 登录之前。 较新的类 Unix 系统可以生成动态消息。 Linux 系统通过 /etc/issue、/etc/http://issue.net、/etc/motd 以及 /run/motd.dynamic 来显示本地或者是远程登录后的提示信息，通常用于向用户提示系统版本、硬件信息等，/etc/issue、/etc/http://issue.net 通常在未登录终端前显示，/etc/motd、/run/motd.dynamic 则是在成功登录终端后显示。 此外还有 /etc/profile 与 /etc/profile.d/，在登录后会运行其中的脚本。 实现方式 通过在线生成ASCII艺术字在线网站，生成想要的提示信息，保存名为motd放入/etc/目录下，重连ssh生效。 通过Neofetch(查询系统信息)+lolcat（炫酷的颜色） 来实现效果 使用教程 [root@localhost ~]# ll /etc/profile.d/ total 88 -rw-r--r--. 1 root root 196 May 16 2022 colorgrep.csh -rw-r--r--. 1 root root 201 May 16 2022 colorgrep.sh -rw-r--r--. 1 root root 1586 Apr 21 2024 colorls.csh -rw-r--r--. 1 root root 1431 Apr 21 2024 colorls.sh -rw-r--r--. 1 root root 162 Jun 15 2022 colorxzgrep.csh -rw-r--r--. 1 root root 183 Jun 15 2022 colorxzgrep.sh -rw-r--r--. 1 root root 216 Oct 30 2022 colorzgrep.csh -rw-r--r--. 1 root root 220 Oct 30 2022 colorzgrep.sh -rw-r--r--. 1 root root 80 Apr 8 2024 csh.local -rw-r--r--. 1 root root 674 Apr 6 2024 debuginfod.csh -rw-r--r--. 1 root root 596 Apr 6 2024 debuginfod.sh -rw-r--r--. 1 root root 831 Apr 18 2024 flatpak.sh -rw-r--r--. 1 root root 1107 Aug 29 2019 gawk.csh -rw-r--r--. 1 root root 757 Aug 29 2019 gawk.sh -rw-r--r--. 1 root root 3424 Jun 23 2020 lang.csh -rw-r--r--. 1 root root 3187 Jun 23 2020 lang.sh -rw-r--r--. 1 root root 500 May 31 08:18 less.csh -rw-r--r--. 1 root root 253 May 31 08:18 less.sh -r-x--x--x 1 root root 51 Oct 25 11:25 neofetch.sh -rw-r--r--. 1 root root 81 Apr 8 2024 sh.local -rw-r--r--. 1 root root 120 Oct 26 2023 which2.csh -rw-r--r--. 1 root root 540 Oct 26 2023 which2.sh [root@localhost ~]# cat /etc/profile.d/neofetch.sh #/bin/sh cat /etc/motdz | lolcat \u0026\u0026 neofetch --off [root@localhost ~]# cat /etc/motdz ______ __ __ ______ __ / \\ / | / | / | / | /$$$$$$ | ______ _______ _______ $$ |____ $$/ _______ $$$$$$/ _____ ____ ______ ______ _______ _$$ |_ $$ | _$$/ / \\ / \\ / |$$ \\ / |/ \\ $$ | / \\/ \\ / \\ / \\ / |/ $$ | $$ |/ |/$$$$$$ |$$$$$$$ |/$$$$$$$/ $$$$$$$ |$$ |$$$$$$$ | $$ | $$$$$$ $$$$ |/$$$$$$ | $$$$$$ |/$$$$$$$/ $$$$$$/ $$ |$$$$ |$$ $$ |$$ | $$ |$$ \\ $$ | $$ |$$ |$$ | $$ | $$ | $$ | $$ | $$ |$$ | $$ | / $$ |$$ | $$ | __ $$ \\__$$ |$$$$$$$$/ $$ | $$ | $$$$$$ |$$ | $$ |$$ |$$ | $$ | _$$ |_ $$ | $$ | $$ |$$ |__$$ |/$$$$$$$ |$$ \\_____ $$ |/ | $$ $$/ $$ |$$ | $$ |/ $$/ $$ | $$ |$$ |$$ | $$ | / $$ |$$ | $$ | $$ |$$ $$/ $$ $$ |$$ | $$ $$/ $$$$$$/ $$$$$$$/ $$/ $$/ $$$$$$$/ $$/ $$/ $$/ $$/ $$/ $$$$$$/ $$/ $$/ $$/ $$$$$$$/ $$$$$$$/ $$$$$$$/ $$$$/ $$ | $$ | $$/ [root@localhost ~]# Linux系统之neofetch工具的基本使用-腾讯云开发者社区-腾讯云 Linux系统之neofetch工具的基本使用 – 知乎 Linux 自定义 Neofetch 的输出信息-CSDN博客 Linux 中 9 个鲜为人知的 Neofetch 使用方法 – Linux迷 技术|lolcat ：一个在 Linux 终端中输出彩虹特效的命令行工具 ","date":"2025-12-17","objectID":"/posts/28260a2/:0:0","tags":["welcome","自定义欢迎语"],"title":"linux终端自定义欢迎语，欢迎界面","uri":"/posts/28260a2/"},{"categories":["linux"],"content":"yum/dnf运行报错，重启系统后网络无法连接 linux组件底层依赖openssl 1.0.0版本导致的程序在编译的时候采用的是1.0版本的openssl库。升级后，导致动态库不兼容，感觉应该是openssl版本太新了，而yum\\dnf这些包管理器，要用到一些旧版本的依赖 解决方法 1.ssl降级重新编译安装旧版本 **2.从本机或者其他机器上找到libcrypt.so.和libssl.so.文件，复制到问题机器的/lib64目录，在创建1.0版本的符号链接。将错误的软连接删除，恢复成为旧的链接 [root@localhost ~]# ll /usr/lib64/libcrypto.so* -rwxr-xr-x. 1 root root 3357304 Oct 23 18:09 /usr/lib64/libcrypto.so.1.1 lrwxrwxrwx. 1 root root 29 Oct 23 18:37 /usr/lib64/libcrypto.so.3 -\u003e /usr/lib64/libcrypto.so.3.0.7 -rwxr-xr-x. 1 root root 4487176 Sep 19 03:33 /usr/lib64/libcrypto.so.3.0.7 [root@localhost ~]# ll /usr/lib64/libssl.so* -rwxr-xr-x. 1 root root 689520 Oct 23 18:09 /usr/lib64/libssl.so.1.1 lrwxrwxrwx. 1 root root 26 Oct 23 18:38 /usr/lib64/libssl.so.3 -\u003e /usr/lib64/libssl.so.3.0.7 -rwxr-xr-x. 1 root root 688352 Sep 19 03:33 /usr/lib64/libssl.so.3.0.7 #新建/usr/lib64/libcrypto.so.3，/usr/lib64/libcrypto.so.3两个连接，并将旧链接/usr/lib64/libcrypto.so.3.0.7，/usr/lib64/lib.so.3.0.7指向它们 [root@localhost ~]# ln -s /usr/lib64/libcrypto.so.3.0.7 /usr/lib64/libcrypto.so.3 [root@localhost ~]# ln -s /usr/lib64/libssl.so.3.0.7 /usr/lib64/libssl.so.3 OpenSSL升级后导致libcrypt.so.10和libssl.so.10找不到的解决_libssl.so.10 找不到-CSDN博客 参考： ImportError: /usr/1ib64/1ibldap,so,2: undefined symbol: EVP-md2， version OPENSSL_1_1_0 – Justtosee – 博客园 OpenSSL版本历史_openssl所有版本-CSDN博客 历时3年，OpenSSL 3.0 正式发布！弃用所有低级别API – 知乎 undefined symbol: EVP_mdc2, version OPENSSL_1_1_0 · Issue #11670 · openssl/openssl CentOS libssl.so.10及libcrypto.so.10缺失导致sudo、yum等命令报错-腾讯云开发者社区-腾讯云 OpenSSL升级后导致libcrypt.so.10和libssl.so.10找不到的解决_libssl.so.10 找不到-CSDN博客 linux系列8.2系统升级openssl导致的连锁问题 – K\u0026 – 博客园 ","date":"2025-12-17","objectID":"/posts/7258f78/:0:0","tags":["openssl","ssl","dnf error"],"title":"linux升级openssl到最新版，yumdnf运行报错，重启系统后网络无法连接","uri":"/posts/7258f78/"},{"categories":["linux"],"content":"输入命令的时候提示：command not found linux命令行下面执行某个命令的时候，首先保证该命令是否存在，若存在，但输入命令的时候若仍提示：command not found 这个时候就的查看PATH环境变量的设置了，当前命令是否存在于PATH环境变量中 #查看PATH： echo $PATH #举例说，命令 composr 在/usr/loca/bin 但执行的时候提示： -bash: composr: command not found 这个时候，通过echo $PATH，，发现composer并未在PATH环境变量中有设置，这个时候就需要把composer所在路径添加到PATH中 修改PATH环境变量 所以需要修改PATH环境变量，具体如下： #方法一： #配置完后可以通过echo $PATH查看配置结果。 #生效方法：立即生效 #有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢#复原有的path配置 #用户局限：仅对当前用户 export PATH=/usr/local/bin:$PATH #方法二： #通过修改.bashrc文件: vim ~/.bashrc #在最后一行添上： export PATH=/usr/local/bin:$PATH #生效方法：（有以下两种） #1、关闭当前终端窗口，重新打开一个新终端窗口就能生效 #2、输入“source ~/.bashrc”命令，立即生效 source ~/.bashrc #有效期限：永久有效 #用户局限：仅对当前用户 #方法三： #通过修改profile文件: vim /etc/profile export PATH=/usr/local/bin:$PATH #生效方法：系统重启 #有效期限：永久有效 #用户局限：对所有用户 #方法四： #通过修改environment文件: vim /etc/environment 在PATH=\"/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin\"中加入 \":/usr/local/bin\" #生效方法：系统重启 #有效期限：永久有效 #用户局限：对所有用户 注意事项 系统在环境变量中寻找程序路径时，是由前往后，由上往下的方式寻找的，找到第一个后九会直接使用它而不会再往后往下寻找了。 所以在将程序路径复制进入到path或者其他环境变量名中时，需要如果原先已经配置过这个程序的路径，那么系统会使用先找到的那个路径，所有为了保证系统使用的是我们最新配置的路径，一般我们直接把新配置的路径写在最上面或者最前面。 ","date":"2025-12-17","objectID":"/posts/d681069/:0:0","tags":["path"],"title":"linux可执行文件添加到PATH环境变量的方法","uri":"/posts/d681069/"},{"categories":["linux"],"content":"Linux手动升级OpenSSH版本(rocky9.4环境) 1.备份ssh配置数据 mkdir -p /backup/ssh_backup/pam.d cp /etc/pam.d/sshd /backup/ssh_backup/pam.d/ cp -r /etc/ssh /backup/ssh_backup/ 2.下载telnet远程连接工具,telnet常见操作命令（以防万一） [root@localhost ~]# yum install telnet telnet-server -y Last metadata expiration check: 0:00:46 ago on Wed Oct 23 14:22:22 2024. Dependencies resolved. ================================================================================ Package Architecture Version Repository Size ================================================================================ Installing: telnet x86_64 1:0.17-85.el9 appstream 63 k telnet-server x86_64 1:0.17-85.el9 appstream 38 k Transaction Summary ================================================================================ Install 2 Packages Total download size: 101 k Installed size: 179 k Downloading Packages: (1/2): telnet-server-0.17-85.el9.x86_64.rpm 153 kB/s | 38 kB 00:00 (2/2): telnet-0.17-85.el9.x86_64.rpm 256 kB/s | 63 kB 00:00 -------------------------------------------------------------------------------- Total 106 kB/s | 101 kB 00:00 Running transaction check Transaction check succeeded. Running transaction test Transaction test succeeded. Running transaction Preparing : 1/1 Installing : telnet-1:0.17-85.el9.x86_64 1/2 Installing : telnet-server-1:0.17-85.el9.x86_64 2/2 Running scriptlet: telnet-server-1:0.17-85.el9.x86_64 2/2 Verifying : telnet-server-1:0.17-85.el9.x86_64 1/2 Verifying : telnet-1:0.17-85.el9.x86_64 2/2 Installed: telnet-1:0.17-85.el9.x86_64 telnet-server-1:0.17-85.el9.x86_64 Complete! [root@localhost ~]# systemctl start telnet.socket [root@localhost ~]# systemctl enable telnet.socket Created symlink /etc/systemd/system/sockets.target.wants/telnet.socket → /usr/li b/systemd/system/telnet.socket. [root@localhost ~]# firewall-cmd --permanent --add-port=23/tcp Warning: ALREADY_ENABLED: 23:tcp success [root@localhost ~]# firewall-cmd --reload success #3.升级ssh #下载源码，搭建编译环境，编译rpm包 #阿里云ssh源链接： https://mirrors.aliyun.com/pub/OpenBSD/OpenSSH/portable/ 我们只需要下载#XXXX.tar.gz文件就好了 openssh-9.9p1.tar.gz 搭建编译环境 #编译rpm包 yum install wget tree openssl-devel libXt-devel gtk2-devel perl krb5-devel rpm-build rpmdevtools tar pam-devel zlib-devel gcc-c++ -y #注：本页面操作在/root/下运行 # 生成目录结构 [root@localhost ~]# rpmdev-setuptree # 源码及spec文件放入指定目录 mv openssh-9.9p1.tar.gz rpmbuild/SOURCES/ tar zxvf rpmbuild/SOURCES/openssh-9.9p1.tar.gz openssh-9.9p1/contrib/redhat/openssh.spec mv openssh-9.9p1/contrib/redhat/openssh.spec rpmbuild/SPECS/ # 下载 ssh-askpass包 wget -c 断点续传，-P 保存到指定的目录 x11-ssh-askpass - Fedora Packages ##x11-ssh-askpass是用于OpenSSH或其他开放SSH变体的轻量级密码短语对话框。特别是，x11-ssh-askpass对于Damien Miller等人开发的OpenSSH的Unix端口非常有用，并且Damien将其包含在他的OpenSSH RPM包中。X11 -ssh-askpass仅使用常用的X11库（libX11、libXt）作为其用户界面。 #这减少了对外部库（如GNOME或Perl/Tk）的依赖。有关更多信息，请参阅README。 wget https://src.fedoraproject.org/repo/pkgs/openssh/x11-ssh-askpass-1.2.4.1.tar.gz/8f2e41f3f7eaa8543a2440454637f3c3/x11-ssh-askpass-1.2.4.1.tar.gz -c -P rpmbuild/SOURCES/ # 完成后目录结构 [root@localhost ~]# tree rpmbuild/ rpmbuild/ ├── BUILD ├── RPMS ├── SOURCES │ ├── openssh-9.9p1.tar.gz │ └── x11-ssh-askpass-1.2.4.1.tar.gz ├── SPECS │ └── openssh.spec └── SRPMS # 编译并生成rpm cd ~/rpmbuild/SPECS rpmbuild -ba openssh.spec # 编译中会报错缺少imake依赖,但是yum,dnf都下载不了 “Imake是一个已弃用的源代码配置和构建系统，传统上由X11R6和以前版本中的x窗口系统提供并用于构建该系统。 在X窗口系统X11R7发行版中，X窗口系统已经切换到使用GNU自动工具作为主要构建系统，而Imake系统现在已被弃用，不应该在新的软件项目中使用。 鼓励软件开发人员将软件迁移到GNU自动工具系统。” 可以到这里下载（Imake Download (APK, EOPKG, PKG, RPM, TGZ, TXZ, XBPS, XZ, ZST)）imake rpm包 wget https://dl.rockylinux.org/pub/rocky/8/PowerTools/x86_64/os/Packages/i/imake-1.0.7-11.el8.x86_64.rpm #安装imake rpm -ivh imake-1.0.7-11.el8.x86_64.rpm # 编译完成后的rpm包生成在rpmbuild/RPMS目录中 [root@localhost ~]# ls rpmbuild/RPMS/x86_64/ openssh-9.9p1-1.el9.x86_64.rpm openssh-clients-debuginfo-9.9p1-1.el9.x86_64.rpm openssh-askpass-9.9p1-1.el9.x86_64.rpm openssh-debuginfo-9.9p1-1.el9.x86_64.rpm openssh-askpass-debuginfo-9.9p1-1.el9.x86_64.rpm openssh-debugsource-9.9p1-1.el9.x86_64.rpm openssh-askpass-gnom","date":"2025-12-17","objectID":"/posts/e7e6a08/:0:0","tags":["openssh","ssh","sshupdate"],"title":"Linux手动升级OpenSSH版本(rocky9.4环境)","uri":"/posts/e7e6a08/"},{"categories":["blog"],"content":"一个 Hugo 网站的 Giscus 评论系统配置。 配置概览 这是一个 FixIt 主题（v0.2.14+）的 Giscus 评论系统配置。 关键参数分析 # 基础配置 enable = false # 是否启用 Giscus，当前为关闭状态 repo = \"jiang1bo/jiang1bo\" # GitHub 仓库：用户 jiang1bo 下的 jiang1bo 仓库 repoId = \"xxxxxOQgMS0A\" # GitHub 仓库的唯一 ID category = \"General\" # 讨论分类名称 categoryId = \"xxxxxwDOQgMS0M4CzSCX\" # 分类的唯一 ID # 映射设置 mapping = \"pathname\" # 页面映射方式：使用路径名作为标识 origin = \"https://giscus.app\" # Giscus 客户端源（FixIt 0.3.7+ 支持自托管） # 功能开关 strict = \"0\" # 严格模式：0=不严格，1=严格匹配 reactionsEnabled = \"1\" # 是否启用表情反应：1=启用 emitMetadata = \"0\" # 是否发送元数据：0=不发送 inputPosition = \"bottom\" # 评论框位置：bottom（底部），可选 top（顶部） # 主题配置 lightTheme = \"light\" # 亮色主题名称 darkTheme = \"dark\" # 深色主题名称 lazyLoad = true # 是否懒加载评论组件 工作原理 1. Giscus 是什么？ 基于 GitHub Discussions 的评论系统 开源、免费、无需数据库 使用 GitHub 账号登录评论 2. 配置步骤分析 你需要已经完成了以下步骤： 创建了 GitHub 仓库 jiang1bo/jiang1bo 启用了 GitHub Discussions 功能 安装了 Giscus App 到仓库 获取了 repoId 和 categoryId 3. 如何获取这些 ID？ 方法一：通过 Giscus 官网 https://giscus.app/ 输入仓库 URL 后会自动生成配置 方法二：通过 GitHub API # 获取 repoId curl -H \"Authorization: token YOUR_TOKEN\" \\ https://api.github.com/repos/jiang1bo/jiang1bo # 获取 categoryId curl -H \"Authorization: token YOUR_TOKEN\" \\ https://api.github.com/repos/jiang1bo/jiang1bo/discussions/categories 优化建议 1. 启用配置 enable = true # 改为 true 以启用评论系统 2. 添加语言配置 lang = \"zh-CN\" # 设置评论界面语言 3. 优化加载策略 lazyLoad = true # 已启用，减少首屏加载时间 4. 安全配置建议 # 如果你有自部署的 Giscus，可以修改 origin origin = \"https://giscus.yourdomain.com\" # 自托管地址 5. 完整的优化配置示例 [params.page.comment.giscus] enable = true repo = \"jiang1bo/jiang1bo\" repoId = \"xxxxDOQgMS0A\" category = \"Announcements\" # 可以创建专用分类 categoryId = \"DIC_xxxxgMS0M4CzSCX\" mapping = \"pathname\" origin = \"https://giscus.app\" strict = \"0\" term = \"\" # 搜索关键词，留空使用默认 reactionsEnabled = \"1\" emitMetadata = \"0\" inputPosition = \"bottom\" lightTheme = \"light\" # 可选：light、light_high_contrast、light_protanopia darkTheme = \"dark\" # 可选：dark、dark_high_contrast、dark_protanopia darkDimmed = \"dark_dimmed\" # 可添加更多主题 lazyLoad = true lang = \"zh-CN\" # 设置语言 故障排查 如果评论不显示，检查以下内容： 仓库权限：确保仓库是公开的 Discussions 已启用：仓库 Settings → Features → Discussions Giscus App 已安装：仓库 Settings → Integrations → Giscus 分类存在：确保 “General” 分类在 Discussions 中存在 性能影响 优点： ✅ 无数据库依赖 ✅ 使用 GitHub 账号，无需注册 ✅ 支持 Markdown 格式 ✅ 响应式设计 推荐设置 对于个人博客，建议： 保留懒加载：lazyLoad = true 启用表情反应：reactionsEnabled = \"1\" 输入框在底部：inputPosition = \"bottom\" 使用 pathname 映射：mapping = \"pathname\" 只需要将 enable 改为 true 即可使用。 ","date":"2025-12-02","objectID":"/posts/5e56024/:0:0","tags":["giscus","Hogo","fixlt"],"title":"通过giscus为博客添加评论系统（Hugo+fixlt+giscus）","uri":"/posts/5e56024/"},{"categories":["Golang"],"content":"Go 语言全面解析：发展史、特点、学习路线与未来趋势 📜 Go 语言发展史 起源与诞生（2007-2009） 2007年：Google 的 Robert Griesemer、Rob Pike 和 Ken Thompson 开始设计 Go 语言 设计目标：解决 C++ 的编译速度慢、依赖管理复杂、并发编程困难等问题 2009年11月：Go 语言正式开源发布，版本号为 Go 1 关键里程碑 2009 :: 开源发布，初版编译器 2012 :: Go 1.0 发布，承诺向后兼容 2015 :: Go 1.5 实现自举（用 Go 编译 Go） 2018 :: Go 1.11 引入 Go Modules 2020 :: Go 1.14 生产环境就绪的 Goroutine 异步抢占 2022 :: Go 1.18 正式支持泛型 2023 :: Go 1.21 增强泛型和工具链 ⚡ Go 语言核心特点 1. 简洁易学的语法 // 经典的 \"Hello, World!\" package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } // 变量声明简洁 name := \"Go\" // 类型推断 var count int = 10 // 显式类型 const Version = \"1.21\" // 常量 2. 强大的并发模型 // Goroutine - 轻量级线程 go func() { fmt.Println(\"Running in goroutine\") }() // Channel - 通信共享内存 ch := make(chan int) go func() { ch \u003c- 42 }() value := \u003c-ch // Select - 多路复用 select { case msg := \u003c-ch1: fmt.Println(msg) case ch2 \u003c- data: fmt.Println(\"sent\") case \u003c-time.After(time.Second): fmt.Println(\"timeout\") } 3. 卓越的性能 编译型语言：直接编译为机器码 垃圾回收：低延迟的并发垃圾收集器 编译速度快：依赖分析精准，增量编译 4. 丰富的标准库 import ( \"net/http\" // HTTP 服务器和客户端 \"encoding/json\" // JSON 处理 \"database/sql\" // 数据库接口 \"crypto\" // 加密算法 \"testing\" // 测试框架 ) 5. 跨平台支持 # 交叉编译示例 GOOS=linux GOARCH=amd64 go build # Linux 64位 GOOS=windows go build # Windows GOOS=darwin go build # macOS 6. 工具链完善 go mod init # 模块初始化 go test # 运行测试 go fmt # 代码格式化 go vet # 静态分析 go doc # 文档生成 🗺️ Go 语言学习路线 阶段 1：基础入门（1-2周） // 学习重点：语法基础、数据类型、控制流 package main import \"fmt\" func main() { // 基本数据类型 var integer int = 42 floating := 3.14 message := \"Hello, Go!\" // 控制结构 if integer \u003e 0 { for i := 0; i \u003c 5; i++ { fmt.Println(i) } } // 函数定义 result := add(10, 20) fmt.Println(result) } func add(a, b int) int { return a + b } 学习资源： A Tour of Go 《Go 语言编程》 阶段 2：核心概念（2-3周） // 学习重点：结构体、接口、错误处理、并发 package main import ( \"errors\" \"fmt\" \"time\" ) // 结构体和接口 type User struct { Name string Age int } type Speaker interface { Speak() string } func (u User) Speak() string { return fmt.Sprintf(\"Hi, I'm %s\", u.Name) } // 错误处理 func divide(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(\"division by zero\") } return a / b, nil } // 并发实践 func worker(id int, jobs \u003c-chan int, results chan\u003c- int) { for job := range jobs { fmt.Printf(\"Worker %d processing job %d\\n\", id, job) time.Sleep(time.Second) results \u003c- job * 2 } } 实践项目： 命令行工具 简单的 Web API 并发文件处理器 阶段 3：进阶技能（3-4周） // 学习重点：标准库、测试、性能优化 package main import ( \"encoding/json\" \"net/http\" \"testing\" ) // HTTP 服务器 func helloHandler(w http.ResponseWriter, r *http.Request) { response := map[string]string{\"message\": \"Hello, World!\"} json.NewEncoder(w).Encode(response) } // 单元测试 func TestAdd(t *testing.T) { result := add(2, 3) if result != 5 { t.Errorf(\"Expected 5, got %d\", result) } } // 性能分析 func BenchmarkProcess(b *testing.B) { for i := 0; i \u003c b.N; i++ { processLargeData() } } 学习重点： net/http 包深度使用 数据库操作（SQL、NoSQL） 测试和性能分析 中间件和认证 阶段 4：实战项目（4-6周） 推荐项目： RESTful API 服务 微服务架构 CLI 工具开发 分布式系统组件 🚀 Go 语言未来趋势 1. 云原生统治地位 // Kubernetes、Docker 等云原生工具大量使用 Go package main import ( \"context\" \"fmt\" metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\" \"k8s.io/client-go/kubernetes\" ) 趋势：在容器编排、服务网格、云基础设施中持续增长 2. 微服务和 API 开发 // 使用 Go 构建高效的微服务 package main import ( \"github.com/gin-gonic/gin\" \"go.uber.org/zap\" ) func main() { r := gin.Default() r.GET(\"/api/users\", getUsers) r.Run(\":8080\") } 3. 区块链和加密货币 以太坊：Geth 客户端使用 Go Hyperledger Fabric：主要用 Go 开发 加密货币工具：钱包、交易所后端 4. 人工智能和机器学习 // 虽然 Python 主导，但 Go 在基础设施层有优势 import ( \"github.com/sjwhitworth/golearn/base\" \"github.com/sjwhitworth/golearn/trees\" ) 5. 边缘计算和 IoT 小型二进制文件适合资源受限环境 跨平台编译支持多种架构 📊 就业市场分析 热门岗位 后端开发工程师（微服务、API） 云原生工程师（Kubernetes、Docker） 基础设施工程师（DevOps、SRE） 区块链开发工程师 系统编程工程师 薪资水平（2024年数据） 经验水平 平均年薪（美国） 平均年薪（中国） 初级（0-2年） $90,000 - $120,000 ¥200,000 - ¥350,000 中级（3-5年） $120,000 - $160,000 ¥350,000 - ¥600,000 高级（5+年） $160,000 - $220,000+ ¥600,000 - ¥1,000,000+ 🛠️ 推荐学习资源 官方资源 Go 官方文档 A Tour of Go Go by Example 书籍推荐 《The Go Programming Language》（Go 语言圣经） 《Go in Action》 《Concurrency in Go》 实战平台 Exercism Go Track LeetCode Go 专题 Go 官方博客实例 💡 学习建议 最佳实践 边学边练：每个概念都要写代码验证 阅读源码：学习标准库和优秀开源项目 参与社","date":"2025-11-29","objectID":"/posts/b6a1b1e/:0:0","tags":["Golang"],"title":"Go 语言全面解析：发展史、特点、学习路线与未来趋势","uri":"/posts/b6a1b1e/"},{"categories":["daily"],"content":"2013年，我在《GTA》的洛圣都考取了机动车驾驶证，虽然主要工作是帮麦克先生处理一些“家庭纠纷”，并致力于通过非暴力方式提升全市居民的平均幸福指数。 ​ 2014年，响应召唤，在《英雄联盟》的召唤师峡谷办理了常住户口，主修“亚索的0/10/0如何不影响队友心态”这一高深课题。 ​ 2015年，通过层层选拔，加入了《战地》系列的硬仗行动，负责在枪林雨弹中为队友提供“人体描边”艺术指导，并深刻理解了“载具杀手”的真正含义——通常指的是我方的载具。 ​ 2016年，正式受聘于《王者峡谷》，担任“河道巡逻员”，负责调解上路与下路的双边贸易纠纷，并统计每日诞生“五杀”的次数。 ​ 2017年，参加了《和平精英》特种兵集训营，系统学习了“伏地魔的自我修养”与“舔包速成指南”。同年，我也在《彩虹六号》的战术模拟中心进修，专攻“墙面装修与拆除”（俗称“敲墙”），并成为了人质救援专家——尽管偶尔会不小心让任务目标提前下班。 ​ 2018年，首先服役于《CS:GO》在炼狱小镇，担任B点守护者，虽然大部分时间都在经济局起“P90 Rush B”中度过。随后，服役于《CF》的运输船，担任“幽灵模式”鬼跳教练，致力于研究如何在不被发现的情况下完成“背刺1+1”。 ​ 2019年，我被调往《使命召唤》战区，在Verdansk执行了长达数年的“高空跳伞——落地成盒”循环任务，锻炼了强大的心理承受能力。同年，我也在《GTA》的线上模式拓展了业务，成为了一名“CEO”，主营空中货运和地下军火贸易，并成功吸引了全城“小哑巴”的友好关注。 ​ 2020年，受邀进入《赛博朋克2077》的夜之城。尽管城市网络漏洞百出，我仍凭借出色的“BUG适应能力”，在“黑梦”体验中坚持完成了任务，并被杰克·威尔斯先生誉为“最能保守秘密（指从不看任务简报）的好兄弟”。 ​ 2021年，意外获得了《原神》的“神之眼”，受聘为提瓦特大陆的荣誉骑士，主要工作是每日清理居民委托、帮厨神香菱寻找稀奇古怪的食材，并在层岩巨渊下进行高强度“采矿”实习。 ​ 2022年，奉命潜入《艾尔登法环》的交界地，在“褪色者新兵训练营”中，我深刻领悟了“生命的脆弱”与“翻滚的重要性”。 ​ 2024年，我奔赴《三角洲行动》前线，经过1个月在““全面战场”下的艰苦战斗，虽然GTI总部说我表现得“既不算出色也不算糟糕”，但我最终还是成功获得了统帅军衔。 ","date":"2025-11-29","objectID":"/posts/06879af/:0:0","tags":["blog","resume","daily","game"],"title":"个人介绍","uri":"/posts/06879af/"},{"categories":["linux"],"content":"从 ubuntu 18.04 开始，修改使用 netplan 方式，新版本也不例外。 编辑网络配置文件（旧系统直接修改/etc/network/interfaces/....） 使用文本编辑器（如vi,vim）打开网络配置文件： cd /etc/netplan sudo vi 50-cloud-init.yaml 要将其修改为静态 IP，配置可能如下（示例 IP 地址为192.168.1.100，子网掩码为24位，网关为192.168.1.1，DNS 服务器为192.168.1.1）： #一个标准配置 network: renderer: networkd ethernets: ens33: # 替换为你的网络接口名称 dhcp4: false # 关闭 DHCP dhcp6: false # 关闭 DHCP addresses: [192.168.100.122/24] # 静态 IP 地址和子网掩码 routes: - to: default via: 192.168.100.1 # 网关地址 nameservers: addresses: [192.168.100.1] # DNS 服务器地址 search: [] version: 2 #一个标准配置 # This is the network config written by 'user' network: ethernets: enp0s3: dhcp4: false addresses: - 10.0.2.15/24 routes: - to: default via: 10.0.2.2 nameservers: addresses: - 114.114.114.114 - 8.8.8.8 version: 2 应用新的网络配置 保存配置文件后，使用以下命令使新配置生效： sudo netplan apply DNSPod的 Public DNS+是目前国内第一家支持ECS的公共DNS，是DNSPod推出的公共域名解析服务，可以为全网用户提供域名的公共递归解析服务！ DNS 服务器 IP 地址： 首选：119.29.29.29 备选：182.254.116.116 阿里公共DNS是阿里巴巴集团推出的DNS递归解析系统，目标是成为国内互联网基础设施的组成部分，面向互联网用户提供“快速”、“稳定”、“智能”的免费DNS递归解析服务。 DNS 服务器 IP 地址： 首选：223.5.5.5 备选：223.6.6.6 ","date":"2024-11-17","objectID":"/posts/b6f57ad/:0:0","tags":["ubuntu","linux","编程","ip地址"],"title":"在 Ubuntu 中修改静态 IP 地址","uri":"/posts/b6f57ad/"},{"categories":["linux"],"content":"几个常见，常用的linux发行版，版本规划以及生命周期 Ubuntu 发布周期 |Ubuntu 浏览器 LTS 或“长期支持”版本每两年在 4 月发布一次。LTS 版本是 Ubuntu 的“企业级”版本，使用最多。估计 95% 的 Ubuntu 安装是 LTS 版本。 Ubuntu LTS 版本对“Main”存储库中的所有包提供 5 年的标准安全维护。通过 Ubuntu Pro 订阅，您可以访问 10 年的扩展安全维护 （ESM），涵盖“Main”和“Universe”存储库中软件包的安全修复。电话和票证支持也可用，并且可以选择添加到 Ubuntu Pro 订阅之上，涵盖 ESM 涵盖的相同软件包，时间范围相同。 Ubuntu Pro 之上的可选旧版支持插件将安全维护和支持延长了 2 年，从而实现了 12 年的总体保修。 在 LTS 版本之间，Canonical 每六个月发布一次 Ubuntu 的临时版本，最新的示例是 24.10。这些是生产质量版本，支持期限为 9 个月，并为用户提供了足够的更新时间，但这些版本没有收到 LTS 版本的长期承诺。 openEuler版本规划及生命周期 长期支持版本：发布间隔周期定为2年，提供4年社区支持。 Rocky 发布版本说明 – Documentation (rockylinux.org) Rocky 9（代号 “Blue Onyx” ）的一般支持直到2027年5月31日为止，安全支持直到2032年5月31日为止。 支持的架构是 x86_64-v2、aarch64、ppc64le 和 s390x。 ","date":"2024-10-14","objectID":"/posts/6764dc1/:0:0","tags":["linux","tech","ubuntu","euler","rocky"],"title":"几个常用linux发行版，支持时间（Ubuntu24，openEuler24，Rocky 9）","uri":"/posts/6764dc1/"},{"categories":["other"],"content":"三方协议注意事项 1.三方协议的签订流程 **三方协议签署顺序：**毕业生→单位→学校，一定不要乱了顺序。 ① 学校统一下发三方协议，或者毕业生敲定工作后拿着单位接收函到学校领取协议，一式三份； ② 毕业生本人填写自己的情况，注意别填错； ③ 寄给用人单位填写、盖章； ④ 返回学校，由学校填写盖章； ⑤ 协议生效，三方各留一份。 2.签三方协议要留心的细节 ① 填写的用人单位名称要与单位的有效印鉴一致，否则协议无效； ② 填写专业名称时，要与学校教务处的专业名称一致，不能简写； ③ 私企试用期通常为3个月，不得超过6个月，签约时要注意； ④ 不少单位为了留住学生，设置高额违约金，同学们在协商中要力争将违约金降到最低，甚至取消。通常违约金不得超过5000元。 ⑤为了防止用人单位言行不一，毕业生可将签约前达成的休假、保险等福利待遇在备注栏中说明，以维护自己合法权利。 3.签三方协议需要小心哪些陷阱？ 陷阱一：备注处留白 现行的三方协议属于“格式合同”范畴，“备注”处容易被忽略。“备注”部分允许三方另行约定各自的权利义务，这中间甚至包括签约前达成的工资、奖金、补贴、福利、股票、五险一金等，为了在发生纠纷时维护自身合法权益，同学们切记，不要随意留白，在备注一栏补充上必要的协商细节。 陷阱二：高额违约金 通常来说，违约金的金额由学生和用人单位协定，重要岗位会有些许提高。但有些用人单位为了“留住”学生，以高额违约金来作为约束条件。大学生在签订合同时，务必看清，以免被违约金束缚手脚，阻碍道路。 陷阱三：实习期当作试用期 对于刚出校门的大学生来说，实习期和试用期往往傻傻分不清楚，签订实习合同而非试用合同。 三方协议与劳动合同： 三方协议是确定就业及用人意向，而劳动合同是确定劳资关系。 法律并没有专门针对对三方协议予以明确的规定，因不存在劳资关系，所以三方协议中的违约金更多地适用于《民法通则》与《合同法》。而劳动合同则是适用于《劳动法》与《合同法》。 实习期与试用期 很多小伙伴知道实习期不能超6个月。可是仅仅知道这一点还是很容易被套路。比如，就签一年合同也让你试用六个月。 其实正式规定是： 合同期限三个月以上不满一年的，试用期不得超过一个月； 劳动合同期限一年以上不满三年的，试用期不得超过二个月； 三年以上固定期限和无固定期限的劳动合同，试用期不得超过六个月。 不满三个月的，不得约定试用期。 试用期是建立在你们已经签订正式劳动合同的基础上。机智的用人单位趁你还没毕业就跟你先签了一份实习合同。实习和试用不只文字区分，更在于性质完全不一样。这份实习合同只是普通的劳务关系，不是劳动法保护的劳动关系，用人单位按工作量给你钱就行，无需提供保险、福利等待遇，想什么时候开除你就开除你。 工资按小时算 按照劳动合同法规定，试用期工资不得低于本单位相同岗位工资标准的80%，且不得低于当地的最低工资标准。 长春某大学的应届毕业生小雪今年在网上应聘了一家娱乐传媒有限公司，顺利上岗，工作一个月后，终于盼来了第一笔工资，但却只有160.25元。而同时期长春市月最低工资标准是1480元。 小雪表示之前的合同标注第一个月基础工资明明是1750元。可单位表示“我们走的是绩效工资，做多少工作，开多少钱，她虽然在我们这工作，但不出活儿啊。”扣除未完成工作和迟到罚款，就剩下160.25元。 这就是用人单位第三个套路，把工资拆解来降低你的收入。法律规定试用期不能低于相同岗位工资标准的80%，他就告诉你其他人的基本工资是2000（只比最低标准多一点），剩下那4000多都是绩效或奖金。所以那个80%，只能以基本工资2000的标准算。 其实还有更狠的，让你连当地最低标准的月工资都拿不到。 陷阱一：签“以完成一定工作任务为期限的劳动合同”，就像小雪这样，没有所谓的“底薪”或“基本工资”，定量工作完成了就有钱，但老板要是说完成得不合格就没钱。 陷阱二：采用非全日制用工的形式，以小时计酬，付你工资时不低于规定的最低小时工资标准即可。你一个月拿到的钱能不能活，那他们就不管了。 面对这种套路，阿熊只能告诉你，小心合同中的“绩效”或者“考核办法”的字样，一定要问清楚他们的含义，否则你连你工资怎么没的都不知道。 档案邮寄地址 办公地址：上蔡县蔡都大道29号 河南省驻马店市上蔡县人力资源和社会保障局南环一路29号4楼 办公时间：上午：8：00-12：00 下午：2：30-5:30(冬季） 上午：8：00-12：00 下午：3：00-6:00(夏季） 负责人姓名： 杨伟新 联系电话：0396-6963006 上蔡县人才交流中心 驻马店市上蔡县（户籍为上蔡县的毕业生） 接收单位：上蔡县人才交流中心 接收地址：河南省驻马店市上蔡县南环一路175号 接 收 人：档案室（收） 0396-6911639 ","date":"2024-08-08","objectID":"/posts/ceddaa5/:0:0","tags":["三方协议"],"title":"三方协议注意事项","uri":"/posts/ceddaa5/"},{"categories":["daily"],"content":"一些有趣的文字，关于科技与音乐的评价,动物园的狮子 关于科技与音乐的评价 英国科幻作家道格拉斯·亚当斯有句话可以直接回答～{银河系漫游指南作者} 任何在我出生时已经有的科技都是稀松平常世界未来秩序的一部分； 任何在我15-35岁之间诞生的科技都是将会改变世界的革命性产物； 任何在我35岁之后诞生的科技都是违反自然规律甚至要遭天谴的！ 我懂事之前的音乐都是老古董，陈旧古板，注定被时代淘汰。 我青春期时期的音乐都是真正的音乐，时尚前卫有内容，称得上是艺术。 我中年之后的音乐都是小屁孩听的口水歌垃圾乐，面目前非不成样子，根本连歌都算不上。 动物园的狮子 动物园里的狮子是一头真正狮子。可是一个的小孩，他指着那头狮子说：“那是一条狗！”围观群众哈哈大笑，纷纷道： “那明明是狮子，你眼瞎了吧！”“动脑子想想，动物园怎么可能让一条狗去假扮狮子，这个动物园这么有钱，他们又不是买不起狮 子。”“那明明是狮子，不给出石锤，就告你造谣。”小孩子哪受得了这种委屈？他纵身跳下假山，和那头狮子来了个脸对脸。 他用剪刀了狗的尾巴——狮子没有这样的尾巴，又用剪刀下了狗的鬃毛，大声道：“你们看，这是狮子吗？！”围观群众一瞬间沉默了。 狮子愤怒的想小孩扑去，愤怒的说的：“我不是狮子nmbs。”围观群众再次沸腾：“看吧！我就知道它肯定是一条狗，快看狗急跳墙了哈哈哈哈哈哈”“都说了你是癞皮狗了，你就别丢人啦！”接着狮子由于攻击人类而被要出死那个小孩发出了仓鼠一样的笑声。狮子哭着坐到地上。孩子走到狮子面前，道：“你知道为什么你斗不过我吗？” 还没等狮子回答，孩子又道：“那些围观群众，都是我花钱雇的，那剪刀也是背后有人给我准备好的。” 狮子瞪大了眼睛。孩子又说：“很委屈对不对？但这个世界就是这样的，人都是不管事实只爱看热闹的羊罢了，我在前面领着他们走他们便会无脑的跟在我后面你叫了这么久，大家看到的还不是人们喜欢我的样子？”孩子又说：“我可以天天剪掉你的毛发，你能天天长出来吗？省省吧，现在人们站在我这边，全社会都在帮我就算你有天大的能耐你又奈我何。”孩子又说：“就算你真的证明了你是狮子又能怎么样？人们希望你是狗，这些群众看了我几天了，他们也希望他们看的是一只狗，所有人都希望你是一只狗，所以你就是狗。”“可是我就是狮子！” “这不重要！”孩子大声道。临走之前，孩子小声对狮子说了一句话：“告诉你一个秘密。”“这些人根本就没看过狮子，他们不知道狮子长什么样，他们也不在乎狮子是怎样的。他们只是一群蠢货，我装得像个拆开真相的人给他们看，他们就很开心了。”“这些人根本就不配看到真正的狮子。” ","date":"2024-08-07","objectID":"/posts/828522d/:0:0","tags":["context","record"],"title":"一些有趣的文字","uri":"/posts/828522d/"}]